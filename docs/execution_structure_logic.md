# 구조, 로직

1. read input  
2. Analysis input  
   a. parentheses & quote check  
   b. tokenize  
   c. syntax check  
   d. parse  
3. execute  


### 명령어 토큰화 규칙

1. 입력의 끝이 있으면 현재 판단중인 문자열을 토큰으로 만든다.

2. 이전 문자가 operator의 일부이면서 현재 문자가 따옴표가 아니고
   이전문자와 연결해서 operator 취급이 되면 operator의 일부다.

3. 이전 문자가 operator의 일부고,
   현재 문자가 이전이랑 연관해서 operator가 아니라면 이전 문자까지가 operator로 토큰화된다.

4. ", ', ( 문자로 시작되면 닫는 문자가 나오기 전까지 문자들을 문자 그대로 인식한다.

5. 현재 문자가 "에 감싸져있지 않은 `$`라면, 쉘은 확장 가능한 것인지 확인하거나, 명령으로 대체한다.

6. 현재 문자가 " 안에 없고, operator의 시작이 될 수 있으면 토큰화한다. 그리고 현재 문자는 새로운 문자의 시작이 된다.

7. 공백을 만나면 지금까지 넣은 것을 토큰화 한다. 공백은 무시한다.

8. 전 문자가 단어의 일부라면 현 문자도 단어의 일부다.

9. 새로운 문자 시작.

### 실행 로직
1. 부모에서 command_argv보고, 빌트인인지 판단한다.
   - 다음 명령어가 파이프라면 파이프를 뚫는다.
   - 명령어를 확인 후 $, *에 대해 확장한다.
   - 리다이렉션을 제외한 명령어만 남긴다.
   1. 빌트인 경우
      - 다음 명령어가 파이프라면
        - 프로세스 fork 후 자식 프로세스에서 파이프 fd를 설정한다. 
        - 리다이렉션이 존재한다면 fd를 설정한다.
        - 빌트인 명령어를 실행한다.
      - 다음 명령어가 파이프가 아니라면
        - 리다이렉션이 존재한다면 fd를 설정한다.
        - 부모에서 빌트인 명령어를 실행한다.
   2. 빌트인이 아닌 경우
      - 프로세스를 fork해 자식 프로세스를 생성한다.
      - 다음 명령어가 파이프라면, 파이프 fd를 설정한다.
      - 리다이렉션이 존재한다면 fd를 설정한다.
      - 현재 폴더에서 실행해야하는 프로그램이라면 별다른 처리를 하지 않는다. 아니라면 PATH 환경변수에 있는 경로를 대입해 프로그램이 있는지 찾는다.
      - 실행한다.
2. 모든 명령어에 대한 처리가 끝나면 부모 프로세스는 자식 프로세스를 wait한다. 받은 exit status를 갱신한다. 



### 파이프라인을 잇는 로직 상세 설명
```c
infile | yes | head -2 | outfile

1. 부모 fd : 0 1 2 3(curr_in) 4(curr_out)
2. 자식 fd : 0 1 2 3(curr_in) 4(curr_out) 5 (prev_in) -> infile
3. 자식 fd : 0 1 2 X(*)       X           X
		execve(yes) -> 1번 파이프에 계속 쓰고 있다.
4. 부모 fd : 0 1 2 3(prev_in = curr_in) // yes는 pipe에 계속 쓰고 있음
5. 부모 fd : 0 1 2 3(prev_in) 4(curr_pipe_out)
6. 자식 fd : 0 1 2 3(prev_in) 4(curr_pipe_out)
7. 자식 fd : 0 1 2 X          X
		execve(head) -> curr_pipe_out에 계속 쓰고 있다.
8. 부모 fd : 0 1 2 X(*)       X
```
- SIGPIPE: write on a pipe with no reader
    - reader는 `프로세스`가 아닌 `읽기 버퍼, fdpipe[0]`으로 본다.
- yes를 실행하기 전 부모프로세스에서 3번 FD, 자식 프로세스에서 3번 FD는 1번 파이프의 reader로 본다.
    - 이 두 FD 모두 닫히지 않는다면 SIGPIPE 신호를 보낼 수 없다.
    - 자식 프로세스에서 3번 FD를 닫지 않고, execve로 yes를 실행한다면 커널 버퍼에 3번 FD가 여전히 남아 있으므로, SIGPIPE 신호를 보낼 수 없다. (즉, 자식에서 curr_in을 닫고 pipe를 실행해야 한다.)
    - 부모 프로세스에서 3번 FD를 닫는 순간, 모든 reader가 닫히므로 SIGPIPE로 인해 yes 프로세스는 스스로 종료한다.
